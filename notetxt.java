/* notetxt.java
 *
 * This program translates a .note file containing notes 
 * generated by a note trancriber to a single-line text 
 * representation.
 *
 * Author: Carlos Gomez
 */

import java.io.*;
import java.util.*;
import java.lang.Math;

class Note implements Comparable<Note> {
    public float time;
    public float duration;
    public int pitch;
    
    Note(float t, float d, int p) {
        time = t;
        duration = d;
        pitch = p;
    }

    public int compareTo(Note b) {
        if (this.time < b.time) {
            return -1;
        } else if (this.time > b.time) {
            return 1;
        } else {
            return 0;
        }
    }
}

class notetxt {

    static String scale[] = {"do", "#do", "re", "#re", "mi", "fa", "#fa", "sol", 
                             "#sol", "la", "#la", "si"};

    public String translate(String filename) {
        String txt = "";
        BufferedReader reader;
        try {
            reader = new BufferedReader(new FileReader(filename));
        } catch (Exception e) {
            System.out.println(filename + ": error opening the file");
            return "";
        }
        String line = "";
        Vector<Note> notes = new Vector<Note>();
        try {
            line = reader.readLine();
            while(line != null) {
                String fields[] = line.split(" ");
                if (fields.length != 4) throw new NumberFormatException();
                float time = Float.parseFloat(fields[1]);
                float duration = Float.parseFloat(fields[2]);
                int pitch = Math.round(Float.parseFloat(fields[3]));
                notes.add(new Note(time, duration, pitch));
                line = reader.readLine();
            }
        } catch (IOException e) {
            System.out.println(filename + ": error reading the file");
            return "";
        } catch (NumberFormatException e) {
            System.out.println(line + ": number format exception");
            System.out.println("while reading file " + filename);
            return "";
        }
        if (!isSorted(notes)) Collections.sort(notes);
        if (notes.size() == 0) return "";
        for (int i = 0; i < notes.size() - 1; i++) {
            Note note = notes.get(i);
            String s_note = pitchToStr(note.pitch);
            float fduration = notes.get(i + 1).time - note.time;
            int duration = Math.round(fduration * 120 * 480 / 60000);
            txt += s_note + duration + " ";
        }
        // print the last note
        Note note = notes.lastElement();
        int duration = Math.round(note.duration * 120 * 480 / 60000);
        txt += pitchToStr(note.pitch) + duration;
        return txt;
    }

    private String pitchToStr(int pitch) {
        int degree = pitch % 12;
        int octave = (pitch / 12) - 5;
        String c = "^";
        if (octave < 0) {
            c = ",";
            octave = -octave;
        }
        String s_octave = "";
        for (int j = 0; j < octave; j++) {
            s_octave += c;
        }
        return scale[degree] + s_octave;
    }

    private boolean isSorted(Vector<Note> v) {
        for (int i = 1; i < v.size(); i++) {
            if (v.get(i).time <= v.get(i - 1).time) return false;
        }
        return true;
    }

    public static void main(String[] args) {
        int argc = args.length;
        boolean nl = false;
        int i = 0;
        if (argc < 1) {
            System.out.println("\nUsage: notetxt [-n] <file>\n");
            return;
        }
        if (args[0].equals("-n")) {
            nl = true;
            i = 1;
            if (argc == 1) {
                System.out.println("\nUsage: notetxt [-n] <file>\n");
                return;
            }
        }
        notetxt nt = new notetxt();
        for (; i < argc; i++) {
            System.out.print(nt.translate(args[i]));
            if (nl) System.out.print("\n");
        }
    }
}
